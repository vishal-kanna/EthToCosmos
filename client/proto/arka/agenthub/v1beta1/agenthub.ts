// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               unknown
// source: arka/agenthub/v1beta1/agenthub.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "arka.agenthub.v1beta1";

/** AgentOutput defines AI agent output type */
export enum AgentOutput {
  AGENT_OUTPUT_UNSPECIFIED = 0,
  AGENT_OUTPUT_TEXT = 1,
  AGENT_OUTPUT_IMAGE = 2,
  AGENT_OUTPUT_VIDEO = 3,
  AGENT_OUTPUT_AUDIO = 4,
  UNRECOGNIZED = -1,
}

export function agentOutputFromJSON(object: any): AgentOutput {
  switch (object) {
    case 0:
    case "AGENT_OUTPUT_UNSPECIFIED":
      return AgentOutput.AGENT_OUTPUT_UNSPECIFIED;
    case 1:
    case "AGENT_OUTPUT_TEXT":
      return AgentOutput.AGENT_OUTPUT_TEXT;
    case 2:
    case "AGENT_OUTPUT_IMAGE":
      return AgentOutput.AGENT_OUTPUT_IMAGE;
    case 3:
    case "AGENT_OUTPUT_VIDEO":
      return AgentOutput.AGENT_OUTPUT_VIDEO;
    case 4:
    case "AGENT_OUTPUT_AUDIO":
      return AgentOutput.AGENT_OUTPUT_AUDIO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AgentOutput.UNRECOGNIZED;
  }
}

export function agentOutputToJSON(object: AgentOutput): string {
  switch (object) {
    case AgentOutput.AGENT_OUTPUT_UNSPECIFIED:
      return "AGENT_OUTPUT_UNSPECIFIED";
    case AgentOutput.AGENT_OUTPUT_TEXT:
      return "AGENT_OUTPUT_TEXT";
    case AgentOutput.AGENT_OUTPUT_IMAGE:
      return "AGENT_OUTPUT_IMAGE";
    case AgentOutput.AGENT_OUTPUT_VIDEO:
      return "AGENT_OUTPUT_VIDEO";
    case AgentOutput.AGENT_OUTPUT_AUDIO:
      return "AGENT_OUTPUT_AUDIO";
    case AgentOutput.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** AgentMode defines AI agent mode */
export enum AgentMode {
  AGENT_MODE_UNSPECIFIED = 0,
  AGENT_MODE_PRIVATE = 1,
  AGENT_MODE_PUBLIC = 2,
  UNRECOGNIZED = -1,
}

export function agentModeFromJSON(object: any): AgentMode {
  switch (object) {
    case 0:
    case "AGENT_MODE_UNSPECIFIED":
      return AgentMode.AGENT_MODE_UNSPECIFIED;
    case 1:
    case "AGENT_MODE_PRIVATE":
      return AgentMode.AGENT_MODE_PRIVATE;
    case 2:
    case "AGENT_MODE_PUBLIC":
      return AgentMode.AGENT_MODE_PUBLIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AgentMode.UNRECOGNIZED;
  }
}

export function agentModeToJSON(object: AgentMode): string {
  switch (object) {
    case AgentMode.AGENT_MODE_UNSPECIFIED:
      return "AGENT_MODE_UNSPECIFIED";
    case AgentMode.AGENT_MODE_PRIVATE:
      return "AGENT_MODE_PRIVATE";
    case AgentMode.AGENT_MODE_PUBLIC:
      return "AGENT_MODE_PUBLIC";
    case AgentMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Organization holds details of organization */
export interface Organization {
  id: number;
  name: string;
  description: string;
  logo: string;
  metadata: Uint8Array;
  admin: string;
  agentId: number[];
}

/** User holds details of agent user */
export interface User {
  address: string;
  name: string;
  profileImage: string;
  description: string;
}

/** AgentMetadata holds information about agent's input and output */
export interface AgentMetadata {
  /** data holds list of AgentMetadataItem objects */
  data: AgentMetadataItem[];
}

/** AgentInputFieldItem holds information about agent's input data field */
export interface AgentInputFieldItem {
  /** title holds description for AI agent input field. */
  title: string;
  /** field_name is the JSON field name for the agent's input. */
  fieldName: string;
  /** optional specifies whether this field is optional. */
  optional: boolean;
}

/** AgentOutputFieldItem holds information about agent's output data field */
export interface AgentOutputFieldItem {
  /** title holds the description for the AI agent's output field. */
  title: string;
  /** field_name is the JSON field name for the agent's output. */
  fieldName: string;
}

/** AgentMetadataItem holds information about the input and output format for an AI agent. */
export interface AgentMetadataItem {
  /** resource holds the agent's exposed REST URI. */
  resource: string;
  /** method_name specifies the REST method name. */
  methodName: string;
  /** input_fields holds a list of AgentInputFieldItem objects. */
  inputFields: AgentInputFieldItem[];
  /** output_fields holds a list of AgentOutputFieldItem objects. */
  outputFields: AgentOutputFieldItem[];
}

/** Agent holds details of AI agent */
export interface Agent {
  /** agent_id is the unique id of the agent. */
  agentId: number;
  /** name is the name of the agent. */
  name: string;
  /** mode defines the agent's mode, either public or private. */
  mode: AgentMode;
  /** description is a short description of the agent. */
  description: string;
  /** software is a list of software used by the agent (Optional). */
  software: string[];
  /** license is the agent's license. */
  license: string;
  /** repository is the URL for the agent's code repository. */
  repository: string;
  /** metadata holds the agent's metadata. */
  metadata:
    | AgentMetadata
    | undefined;
  /** checksum is the SHA-256 checksum of the agent's code. */
  checksum: string;
  /** user is a list of users who are secondary owners of the agent. */
  user: string[];
  /** owner is the account address of the agent's owner. */
  owner: string;
  /** tags are a list of tags for the agent. */
  tags: string[];
  /** images are a list of image URLs. */
  images: string[];
  /** nft_convertible specifies whether the agent's output can be converted to an NFT. */
  nftConvertible: boolean;
  /** agent_output defines the output format for the agent. */
  agentOutput: AgentOutput;
}

function createBaseOrganization(): Organization {
  return { id: 0, name: "", description: "", logo: "", metadata: new Uint8Array(0), admin: "", agentId: [] };
}

export const Organization = {
  encode(message: Organization, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.logo !== "") {
      writer.uint32(34).string(message.logo);
    }
    if (message.metadata.length !== 0) {
      writer.uint32(42).bytes(message.metadata);
    }
    if (message.admin !== "") {
      writer.uint32(50).string(message.admin);
    }
    writer.uint32(58).fork();
    for (const v of message.agentId) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Organization {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrganization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.logo = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.metadata = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.admin = reader.string();
          continue;
        case 7:
          if (tag === 56) {
            message.agentId.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.agentId.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Organization {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      logo: isSet(object.logo) ? globalThis.String(object.logo) : "",
      metadata: isSet(object.metadata) ? bytesFromBase64(object.metadata) : new Uint8Array(0),
      admin: isSet(object.admin) ? globalThis.String(object.admin) : "",
      agentId: globalThis.Array.isArray(object?.agentId) ? object.agentId.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: Organization): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.logo !== "") {
      obj.logo = message.logo;
    }
    if (message.metadata.length !== 0) {
      obj.metadata = base64FromBytes(message.metadata);
    }
    if (message.admin !== "") {
      obj.admin = message.admin;
    }
    if (message.agentId?.length) {
      obj.agentId = message.agentId.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Organization>, I>>(base?: I): Organization {
    return Organization.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Organization>, I>>(object: I): Organization {
    const message = createBaseOrganization();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.logo = object.logo ?? "";
    message.metadata = object.metadata ?? new Uint8Array(0);
    message.admin = object.admin ?? "";
    message.agentId = object.agentId?.map((e) => e) || [];
    return message;
  },
};

function createBaseUser(): User {
  return { address: "", name: "", profileImage: "", description: "" };
}

export const User = {
  encode(message: User, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.profileImage !== "") {
      writer.uint32(26).string(message.profileImage);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): User {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.profileImage = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      profileImage: isSet(object.profileImage) ? globalThis.String(object.profileImage) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.profileImage !== "") {
      obj.profileImage = message.profileImage;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.address = object.address ?? "";
    message.name = object.name ?? "";
    message.profileImage = object.profileImage ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseAgentMetadata(): AgentMetadata {
  return { data: [] };
}

export const AgentMetadata = {
  encode(message: AgentMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.data) {
      AgentMetadataItem.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AgentMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data.push(AgentMetadataItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentMetadata {
    return {
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => AgentMetadataItem.fromJSON(e)) : [],
    };
  },

  toJSON(message: AgentMetadata): unknown {
    const obj: any = {};
    if (message.data?.length) {
      obj.data = message.data.map((e) => AgentMetadataItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentMetadata>, I>>(base?: I): AgentMetadata {
    return AgentMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentMetadata>, I>>(object: I): AgentMetadata {
    const message = createBaseAgentMetadata();
    message.data = object.data?.map((e) => AgentMetadataItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAgentInputFieldItem(): AgentInputFieldItem {
  return { title: "", fieldName: "", optional: false };
}

export const AgentInputFieldItem = {
  encode(message: AgentInputFieldItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.fieldName !== "") {
      writer.uint32(18).string(message.fieldName);
    }
    if (message.optional !== false) {
      writer.uint32(24).bool(message.optional);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AgentInputFieldItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentInputFieldItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fieldName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.optional = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentInputFieldItem {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      fieldName: isSet(object.fieldName) ? globalThis.String(object.fieldName) : "",
      optional: isSet(object.optional) ? globalThis.Boolean(object.optional) : false,
    };
  },

  toJSON(message: AgentInputFieldItem): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.fieldName !== "") {
      obj.fieldName = message.fieldName;
    }
    if (message.optional !== false) {
      obj.optional = message.optional;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentInputFieldItem>, I>>(base?: I): AgentInputFieldItem {
    return AgentInputFieldItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentInputFieldItem>, I>>(object: I): AgentInputFieldItem {
    const message = createBaseAgentInputFieldItem();
    message.title = object.title ?? "";
    message.fieldName = object.fieldName ?? "";
    message.optional = object.optional ?? false;
    return message;
  },
};

function createBaseAgentOutputFieldItem(): AgentOutputFieldItem {
  return { title: "", fieldName: "" };
}

export const AgentOutputFieldItem = {
  encode(message: AgentOutputFieldItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.fieldName !== "") {
      writer.uint32(18).string(message.fieldName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AgentOutputFieldItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentOutputFieldItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fieldName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentOutputFieldItem {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      fieldName: isSet(object.fieldName) ? globalThis.String(object.fieldName) : "",
    };
  },

  toJSON(message: AgentOutputFieldItem): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.fieldName !== "") {
      obj.fieldName = message.fieldName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentOutputFieldItem>, I>>(base?: I): AgentOutputFieldItem {
    return AgentOutputFieldItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentOutputFieldItem>, I>>(object: I): AgentOutputFieldItem {
    const message = createBaseAgentOutputFieldItem();
    message.title = object.title ?? "";
    message.fieldName = object.fieldName ?? "";
    return message;
  },
};

function createBaseAgentMetadataItem(): AgentMetadataItem {
  return { resource: "", methodName: "", inputFields: [], outputFields: [] };
}

export const AgentMetadataItem = {
  encode(message: AgentMetadataItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.resource !== "") {
      writer.uint32(10).string(message.resource);
    }
    if (message.methodName !== "") {
      writer.uint32(18).string(message.methodName);
    }
    for (const v of message.inputFields) {
      AgentInputFieldItem.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.outputFields) {
      AgentOutputFieldItem.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AgentMetadataItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentMetadataItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resource = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.methodName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.inputFields.push(AgentInputFieldItem.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.outputFields.push(AgentOutputFieldItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentMetadataItem {
    return {
      resource: isSet(object.resource) ? globalThis.String(object.resource) : "",
      methodName: isSet(object.methodName) ? globalThis.String(object.methodName) : "",
      inputFields: globalThis.Array.isArray(object?.inputFields)
        ? object.inputFields.map((e: any) => AgentInputFieldItem.fromJSON(e))
        : [],
      outputFields: globalThis.Array.isArray(object?.outputFields)
        ? object.outputFields.map((e: any) => AgentOutputFieldItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AgentMetadataItem): unknown {
    const obj: any = {};
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    if (message.methodName !== "") {
      obj.methodName = message.methodName;
    }
    if (message.inputFields?.length) {
      obj.inputFields = message.inputFields.map((e) => AgentInputFieldItem.toJSON(e));
    }
    if (message.outputFields?.length) {
      obj.outputFields = message.outputFields.map((e) => AgentOutputFieldItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentMetadataItem>, I>>(base?: I): AgentMetadataItem {
    return AgentMetadataItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentMetadataItem>, I>>(object: I): AgentMetadataItem {
    const message = createBaseAgentMetadataItem();
    message.resource = object.resource ?? "";
    message.methodName = object.methodName ?? "";
    message.inputFields = object.inputFields?.map((e) => AgentInputFieldItem.fromPartial(e)) || [];
    message.outputFields = object.outputFields?.map((e) => AgentOutputFieldItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAgent(): Agent {
  return {
    agentId: 0,
    name: "",
    mode: 0,
    description: "",
    software: [],
    license: "",
    repository: "",
    metadata: undefined,
    checksum: "",
    user: [],
    owner: "",
    tags: [],
    images: [],
    nftConvertible: false,
    agentOutput: 0,
  };
}

export const Agent = {
  encode(message: Agent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.agentId !== 0) {
      writer.uint32(8).uint64(message.agentId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.mode !== 0) {
      writer.uint32(24).int32(message.mode);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    for (const v of message.software) {
      writer.uint32(42).string(v!);
    }
    if (message.license !== "") {
      writer.uint32(50).string(message.license);
    }
    if (message.repository !== "") {
      writer.uint32(58).string(message.repository);
    }
    if (message.metadata !== undefined) {
      AgentMetadata.encode(message.metadata, writer.uint32(66).fork()).ldelim();
    }
    if (message.checksum !== "") {
      writer.uint32(74).string(message.checksum);
    }
    for (const v of message.user) {
      writer.uint32(82).string(v!);
    }
    if (message.owner !== "") {
      writer.uint32(90).string(message.owner);
    }
    for (const v of message.tags) {
      writer.uint32(98).string(v!);
    }
    for (const v of message.images) {
      writer.uint32(106).string(v!);
    }
    if (message.nftConvertible !== false) {
      writer.uint32(112).bool(message.nftConvertible);
    }
    if (message.agentOutput !== 0) {
      writer.uint32(120).int32(message.agentOutput);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Agent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.agentId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.software.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.license = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.repository = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.metadata = AgentMetadata.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.checksum = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.user.push(reader.string());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.images.push(reader.string());
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.nftConvertible = reader.bool();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.agentOutput = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Agent {
    return {
      agentId: isSet(object.agentId) ? globalThis.Number(object.agentId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      mode: isSet(object.mode) ? agentModeFromJSON(object.mode) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      software: globalThis.Array.isArray(object?.software) ? object.software.map((e: any) => globalThis.String(e)) : [],
      license: isSet(object.license) ? globalThis.String(object.license) : "",
      repository: isSet(object.repository) ? globalThis.String(object.repository) : "",
      metadata: isSet(object.metadata) ? AgentMetadata.fromJSON(object.metadata) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
      user: globalThis.Array.isArray(object?.user) ? object.user.map((e: any) => globalThis.String(e)) : [],
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      images: globalThis.Array.isArray(object?.images) ? object.images.map((e: any) => globalThis.String(e)) : [],
      nftConvertible: isSet(object.nftConvertible) ? globalThis.Boolean(object.nftConvertible) : false,
      agentOutput: isSet(object.agentOutput) ? agentOutputFromJSON(object.agentOutput) : 0,
    };
  },

  toJSON(message: Agent): unknown {
    const obj: any = {};
    if (message.agentId !== 0) {
      obj.agentId = Math.round(message.agentId);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.mode !== 0) {
      obj.mode = agentModeToJSON(message.mode);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.software?.length) {
      obj.software = message.software;
    }
    if (message.license !== "") {
      obj.license = message.license;
    }
    if (message.repository !== "") {
      obj.repository = message.repository;
    }
    if (message.metadata !== undefined) {
      obj.metadata = AgentMetadata.toJSON(message.metadata);
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    if (message.user?.length) {
      obj.user = message.user;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.images?.length) {
      obj.images = message.images;
    }
    if (message.nftConvertible !== false) {
      obj.nftConvertible = message.nftConvertible;
    }
    if (message.agentOutput !== 0) {
      obj.agentOutput = agentOutputToJSON(message.agentOutput);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Agent>, I>>(base?: I): Agent {
    return Agent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Agent>, I>>(object: I): Agent {
    const message = createBaseAgent();
    message.agentId = object.agentId ?? 0;
    message.name = object.name ?? "";
    message.mode = object.mode ?? 0;
    message.description = object.description ?? "";
    message.software = object.software?.map((e) => e) || [];
    message.license = object.license ?? "";
    message.repository = object.repository ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? AgentMetadata.fromPartial(object.metadata)
      : undefined;
    message.checksum = object.checksum ?? "";
    message.user = object.user?.map((e) => e) || [];
    message.owner = object.owner ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    message.images = object.images?.map((e) => e) || [];
    message.nftConvertible = object.nftConvertible ?? false;
    message.agentOutput = object.agentOutput ?? 0;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
